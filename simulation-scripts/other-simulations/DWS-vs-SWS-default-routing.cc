/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

// Network topology
/*
              		c2		c3
        		|		|
                    net2|   		|net3
               		|    net23      |
		       [R2]------------[R3]
	       net12 /  |               |  \nett34
	    net1    /   |               |   \    net4
          c1------[R1]  |net26     net35|   [R4]-----c4
             net16  \   |               |   /
                     \  |               |  /  
                       [R6]------------[R5]
                        |   net24       |      
		    net6|		|net5
			|		|
			c6		c5

*/

#include <string>
#include <fstream>
#include "ns3/core-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/internet-module.h"
#include "ns3/applications-module.h"
#include "ns3/network-module.h"
#include "ns3/packet-sink.h"
#include "ns3/ipv4-global-routing-helper.h"
#include "ns3/traffic-control-module.h"
#include "ns3/flow-monitor-helper.h"
#include "ns3/flow-monitor-module.h"

using namespace ns3;
NS_LOG_COMPONENT_DEFINE ("Link Failure");

uint32_t prevLost1 = 0, prevLost2 = 0;
uint64_t prevRxBytes1 = 0,prevRxBytes2 = 0;
double prevTxpkt1 = 0, prevTxpkt2 = 0;

void ThroughputMonitor (FlowMonitorHelper* fmhelper, Ptr<FlowMonitor> flowMon)
{
  std::map<FlowId, FlowMonitor::FlowStats> flowStats = flowMon->GetFlowStats();
  Ptr<Ipv4FlowClassifier> classing = DynamicCast<Ipv4FlowClassifier> (fmhelper->GetClassifier());
  for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator stats = flowStats.begin (); stats != flowStats.end (); ++stats)
  {
    Ipv4FlowClassifier::FiveTuple fiveTuple = classing->FindFlow (stats->first);
    if (fiveTuple.destinationPort == 5000) //flow1 generated by c1
    {
      double Thr1 = ((stats->second.rxBytes-prevRxBytes1) * 8.0)/(1024*1024);
      double lostPkt1 = stats->second.lostPackets - prevLost1;
      double lostRate1 = (lostPkt1 / (stats->second.txPackets - prevTxpkt1))*100;
      prevRxBytes1=stats->second.rxBytes;
      prevLost1 = stats->second.lostPackets;
      prevTxpkt1 = stats->second.txPackets;
      std::cout<<Thr1<<" "<<lostRate1<<" "<<fiveTuple.destinationPort<<std::endl;     
    }
    else if (fiveTuple.destinationPort == 5001) //flow2  generated by c2
    {
      double Thr2 = ((stats->second.rxBytes-prevRxBytes2) * 8.0)/(1024*1024);
      double lostPkt2 = stats->second.lostPackets - prevLost2;
      double lostRate2 = (lostPkt2 / (stats->second.txPackets - prevTxpkt2))*100;
      prevRxBytes2 = stats->second.rxBytes;
      prevLost2 = stats->second.lostPackets;
      prevTxpkt2 = stats->second.txPackets;
      std::cout<<Thr2<<" "<<lostRate2<<" "<<fiveTuple.destinationPort<<std::endl;
    }
  }
  Simulator::Schedule(Seconds(1),&ThroughputMonitor,fmhelper,flowMon);
}

int
main (int argc, char *argv[])
{
//================================================================================
//*********************Intialization and general configuration*******************
//================================================================================
  bool flow_monitor = true;
  bool tracing = false;
  uint32_t maxBytes = 0;
  std::string protocol = "TcpHtcp";
  std::string prefix_file_name = "link-failure ";
//Qdisc setup:
  std::string queueDiscType = "PfifoFast"; 
  uint32_t queueSize = 5000;//in packets
//  std::string filename = "/users/fha6np/ns-workspace/ns-allinone-3.26/ns-3.26/60s-1514MTU-parsed-ts-len-1G.txt";
  std::string filename = "/users/fha6np/ns-workspace/ns-allinone-3.26/ns-3.26/60s-1514MTU-parsed-ts-len.txt";
  double simTime = 10.0;
  uint64_t tcpBuff = 5000000; //in bytes
//
// Allow the user to override any of the defaults at
// run-time, via command-line arguments
//
  CommandLine cmd;
  cmd.AddValue ("tracing", "Flag to enable/disable tracing", tracing);
  cmd.AddValue ("maxBytes", "Total number of bytes for application to send", maxBytes);
  cmd.AddValue ("protocol", "Flag to choose TCP variant", protocol);
  cmd.AddValue("queueSize", "FLoag to specify the queue size",queueSize);
  cmd.AddValue("simTime", "Simulation Time",simTime);
  cmd.AddValue("file_name", "File name", prefix_file_name);
  cmd.Parse (argc, argv);

//Dynamic routing configuration
// The below value configures the default behavior of global routing.
// By default, it is disabled.  To respond to interface events, set to true
  Config::SetDefault ("ns3::Ipv4GlobalRouting::RespondToInterfaceEvents", BooleanValue (true));

//tc layer config at the routers
  TrafficControlHelper tchPfifo;
  tchPfifo.SetRootQueueDisc ("ns3::PfifoFastQueueDisc", "Limit", UintegerValue (queueSize));

//tc layer config at the senders
  TrafficControlHelper tchPfifo1;
  tchPfifo1.SetRootQueueDisc ("ns3::PfifoFastQueueDisc", "Limit", UintegerValue (10000));

//netdev config
 Config::SetDefault ("ns3::Queue::Mode", StringValue ("QUEUE_MODE_PACKETS"));
 Config::SetDefault ("ns3::Queue::MaxPackets", UintegerValue (queueSize));


//TCP settings
  Config::SetDefault ("ns3::TcpSocket::SegmentSize", UintegerValue (1446));
  Config::SetDefault ("ns3::TcpSocket::SndBufSize", UintegerValue (tcpBuff));
  Config::SetDefault ("ns3::TcpSocket::RcvBufSize", UintegerValue (tcpBuff));

  if(protocol == "TcpNewReno")  
    Config::SetDefault ("ns3::TcpL4Protocol::SocketType", TypeIdValue (TcpNewReno::GetTypeId ()));
  else
    Config::SetDefault ("ns3::TcpL4Protocol::SocketType", TypeIdValue (TcpHtcp::GetTypeId ()));

//================================================================================
//**************************** Create Topology *******************************
//================================================================================
//
// Explicitly create the nodes required by the topology (shown above).
//
  NS_LOG_INFO ("Create nodes.");
  Ptr<Node> c1 = CreateObject<Node> ();
  Names::Add ("node1", c1);
  Ptr<Node> c2 = CreateObject<Node> ();
  Names::Add ("node2", c2);
  Ptr<Node> c3 = CreateObject<Node> ();
  Names::Add ("node3", c3);
  Ptr<Node> c4 = CreateObject<Node> ();
  Names::Add ("node4", c4);
  Ptr<Node> c5 = CreateObject<Node> ();
  Names::Add ("node5", c5);
  Ptr<Node> c6 = CreateObject<Node> ();
  Names::Add ("node6", c6);

  Ptr<Node> r1 = CreateObject<Node> ();
  Names::Add ("router1", r1);
  Ptr<Node> r2 = CreateObject<Node> ();
  Names::Add ("router2", r2);
  Ptr<Node> r3 = CreateObject<Node> ();
  Names::Add ("router3", r3);
  Ptr<Node> r4 = CreateObject<Node> ();
  Names::Add ("router4", r4);
  Ptr<Node> r5 = CreateObject<Node> ();
  Names::Add ("router5", r5);
  Ptr<Node> r6 = CreateObject<Node> ();
  Names::Add ("router6", r6);

  NodeContainer net1  (c1, r1);
  NodeContainer net2  (c2, r2);
  NodeContainer net3  (c3, r3);
  NodeContainer net4  (c4, r4);
  NodeContainer net5  (c5, r5);
  NodeContainer net6  (c6, r6);

  NodeContainer net12 (r1, r2);
  NodeContainer net23 (r2, r3);
  NodeContainer net34 (r3, r4);
  NodeContainer net45 (r4, r5);
  NodeContainer net56 (r5, r6);
  NodeContainer net16 (r1, r6);
  NodeContainer net26 (r2, r6);
  NodeContainer net35 (r3, r5);
 
  NodeContainer routers (r1,r2,r3,r4,r5);
  routers.Add (r6);
  NodeContainer nodes (c1,c2,c3,c4,c5);
  nodes.Add (c6);


  NS_LOG_INFO ("Create channels.");

//
// Explicitly create the point-to-point link required by the topology (shown above).
//
  PointToPointHelper pointToPoint;
  pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("1Gbps"));
  pointToPoint.SetChannelAttribute ("Delay", StringValue ("5ms"));

  PointToPointHelper pointToPoint2;
  pointToPoint2.SetDeviceAttribute ("DataRate", StringValue ("1Gbps"));
  pointToPoint2.SetChannelAttribute ("Delay", StringValue ("2ms"));

  NetDeviceContainer ndc1  = pointToPoint2.Install (net1);
  NetDeviceContainer ndc2  = pointToPoint2.Install (net2);
  NetDeviceContainer ndc3  = pointToPoint2.Install (net3);
  NetDeviceContainer ndc4  = pointToPoint2.Install (net4);
  NetDeviceContainer ndc5  = pointToPoint2.Install (net5);
  NetDeviceContainer ndc6  = pointToPoint2.Install (net6);

  NetDeviceContainer ndc12  = pointToPoint2.Install (net12);
  NetDeviceContainer ndc23  = pointToPoint2.Install (net23);
  NetDeviceContainer ndc34  = pointToPoint2.Install (net34);
  NetDeviceContainer ndc45  = pointToPoint2.Install (net45);
  NetDeviceContainer ndc56  = pointToPoint2.Install (net56);
  NetDeviceContainer ndc16  = pointToPoint2.Install (net16);
  NetDeviceContainer ndc26  = pointToPoint2.Install (net26);
  NetDeviceContainer ndc35  = pointToPoint2.Install (net35);

//  NetDeviceContainer.Add
//
// Install the internet stack on the nodes
//
  InternetStackHelper internet;
  internet.Install (nodes);
  internet.Install (routers);

////add dqisc to the router1
//make sure to install the qdisc after installing the Internet stack and before assigining IP address
//  tchPfifo.Install (ndc2.Get (0));
  
  QueueDiscContainer qdiscs1 = tchPfifo.Install (ndc12.Get (0));
  Ptr<QueueDisc> q1 = qdiscs1.Get (0);
//  tchPfifo.Install (ndc12.Get (0)); //install it to R1
  QueueDiscContainer qdiscs2 = tchPfifo.Install (ndc23.Get (0)); //install it to R2 link 2-3
  Ptr<QueueDisc> q2 = qdiscs2.Get (0);
  tchPfifo.Install (ndc34.Get (0)); //install it to R3
  tchPfifo.Install (ndc35.Get (1)); //install it to R3
  tchPfifo.Install (ndc56.Get (1)); //install it to R3
  tchPfifo.Install (ndc26.Get (0)); //install it to R3
  tchPfifo.Install (ndc2.Get (1)); //install it to R3
  tchPfifo.Install (ndc4.Get (1)); //install it to R3

//install tc at sender n1 to control the queue size (txqueuelen)
  tchPfifo1.Install (ndc1.Get (0));
  tchPfifo1.Install (ndc2.Get (0));
  tchPfifo1.Install (ndc3.Get (0));
  tchPfifo1.Install (ndc4.Get (0));

//================================================================================
//********************* Assign IP adresses to the network links  ****************
//================================================================================

  NS_LOG_INFO ("Assign IP Addresses.");
  Ipv4AddressHelper ipv4;

// Hosts IP
  ipv4.SetBase ("10.1.1.0", "255.255.255.0");
  Ipv4InterfaceContainer i1 = ipv4.Assign (ndc1);
  ipv4.SetBase ("10.1.2.0", "255.255.255.0");
  Ipv4InterfaceContainer i2 = ipv4.Assign (ndc2);
  ipv4.SetBase ("10.1.3.0", "255.255.255.0");
  Ipv4InterfaceContainer i3 = ipv4.Assign (ndc3);
  ipv4.SetBase ("10.1.4.0", "255.255.255.0");
  Ipv4InterfaceContainer i4 = ipv4.Assign (ndc4);
  ipv4.SetBase ("10.1.5.0", "255.255.255.0");
  Ipv4InterfaceContainer i5 = ipv4.Assign (ndc5);
  ipv4.SetBase ("10.1.6.0", "255.255.255.0");
  Ipv4InterfaceContainer i6 = ipv4.Assign (ndc6);

// Routers IP
  ipv4.SetBase ("10.1.12.0", "255.255.255.0");
  Ipv4InterfaceContainer i12 = ipv4.Assign (ndc12);
  ipv4.SetBase ("10.1.23.0", "255.255.255.0");
  Ipv4InterfaceContainer i23 = ipv4.Assign (ndc23);
  ipv4.SetBase ("10.1.34.0", "255.255.255.0");
  Ipv4InterfaceContainer i34 = ipv4.Assign (ndc34);
  ipv4.SetBase ("10.1.45.0", "255.255.255.0");
  Ipv4InterfaceContainer i45 = ipv4.Assign (ndc45);
  ipv4.SetBase ("10.1.56.0", "255.255.255.0");
  Ipv4InterfaceContainer i56 = ipv4.Assign (ndc56);
  ipv4.SetBase ("10.1.16.0", "255.255.255.0");
  Ipv4InterfaceContainer i16 = ipv4.Assign (ndc16);
  ipv4.SetBase ("10.1.26.0", "255.255.255.0");
  Ipv4InterfaceContainer i26 = ipv4.Assign (ndc26);
  ipv4.SetBase ("10.1.35.0", "255.255.255.0");
  Ipv4InterfaceContainer i35 = ipv4.Assign (ndc35);
//================================================================================
//********************* Application setup at each node *******************
//================================================================================

  NS_LOG_INFO ("Create Applications.");

//------------------- customer1: HTCP flow sender ------------------------ 
// TCP flow c1 --> c4
  uint16_t port = 5000;
//  uint8_t tos = 0x08; //band 2 (low priority)

  InetSocketAddress destAddress (i4.GetAddress (0), port);
//  destAddress.SetTos (tos);
  BulkSendHelper source ("ns3::TcpSocketFactory", destAddress);
  source.SetAttribute ("MaxBytes", UintegerValue (maxBytes));
  ApplicationContainer sourceApps = source.Install (nodes.Get (0));
  sourceApps.Start (Seconds (0.0));
  sourceApps.Stop (Seconds (simTime));

//------------------- customer2: HTCP flow sender ------------------------ 
// TCP flow c2 --> c3
  port++;
//  uint8_t tos = 0x08; //band 2 (low priority)

  InetSocketAddress destAddress2 (i3.GetAddress (0), port);
//  destAddress.SetTos (tos);
  BulkSendHelper source2 ("ns3::TcpSocketFactory", destAddress2);
  source2.SetAttribute ("MaxBytes", UintegerValue (maxBytes));
  ApplicationContainer sourceApps2 = source2.Install (nodes.Get (1));
  sourceApps2.Start (Seconds (1));
  sourceApps2.Stop (Seconds (simTime));

/*
//------------------- node2: CAIDA1 flow sender ------------------------ 
// UDP flow n2 --> n4

  tos = 0x10; //band 0 (high priority)
  InetSocketAddress destAddress2 (i4.GetAddress (0), 10);
  destAddress2.SetTos (tos);
  UdpReplayTraceClientHelper traceClient2  (destAddress2, filename);
//  traceClient2.SetAttribute ("MaxPacketSize", UintegerValue (1448));
  ApplicationContainer clientApps2 = traceClient2.Install (nodes.Get (1));
  clientApps2.Start (Seconds (1.0));
  clientApps2.Stop (Seconds (simTime));
*/

//------------------- customer4: HTCP flow receiver ------------------------ 
//
  port=5000;
  // HTCP flow receiver app
  PacketSinkHelper sink ("ns3::TcpSocketFactory",
                         InetSocketAddress (Ipv4Address::GetAny (), port));
  ApplicationContainer sinkApps = sink.Install (nodes.Get (3));
  sinkApps.Start (Seconds (0.0));
  sinkApps.Stop (Seconds (simTime));

//------------------- customer3: HTCP flow receiver ------------------------ 
//
  port++;
  // HTCP flow receiver app
  PacketSinkHelper sink2 ("ns3::TcpSocketFactory",
                         InetSocketAddress (Ipv4Address::GetAny (), port));
  ApplicationContainer sinkApps2 = sink2.Install (nodes.Get (2));
  sinkApps2.Start (Seconds (1));
  sinkApps2.Stop (Seconds (simTime));

/*
//------------------- node5: CAIDA2 flow receiver ------------------------ 
// 

  // CAIDA2 flow receiver app
  PacketSinkHelper sink3 ("ns3::UdpSocketFactory",
                         InetSocketAddress (Ipv4Address::GetAny (), 11));
  ApplicationContainer sinkApps3 = sink3.Install (nodes.Get (4));
  sinkApps3.Start (Seconds (0.0));
  sinkApps3.Stop (Seconds (simTime));
*/
//================================================================================
//********************* Calculate and populate routing tables  *******************
//================================================================================
  NS_LOG_INFO ("L3: Populate routing tables.");
  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();

//================================================================================
//************************** Monitoring and tracing Setup ************************
//================================================================================

// Flow monitor
  FlowMonitorHelper fmHelper;
  Ptr<FlowMonitor> allMon = fmHelper.InstallAll();

 if (tracing)
 {
//   AsciiTraceHelper ascii;
//   pointToPoint2.EnableAsciiAll (ascii.CreateFileStream ("link-failure.tr"));
   // Trace routing tables 
   Ipv4GlobalRoutingHelper g;
   Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper> ("dynamic-global-routing.routes", std::ios::out);
   g.PrintRoutingTableAllAt (Seconds (1), routingStream);
//   g.PrintRoutingTableAllAt (Seconds (9), routingStream);
   
   //capture pcap
//    pointToPoint2.EnablePcapAll ("link-failure", true);
 }


//================================================================================
//************************** RUN THE SIMULATION ************************
//================================================================================

  //schedule monitoring flows throughput
  Simulator::Schedule(Seconds(1),&ThroughputMonitor,&fmHelper, allMon);
  std::cout<<"Throughput(Mbps) lost-rate(%) dest-port\n";
  
  NS_LOG_INFO ("Run Simulation.");
  Simulator::Stop (Seconds (simTime));
  Simulator::Run ();
  Simulator::Destroy ();
  NS_LOG_INFO ("Done.");


//================================================================================
//************************** Print statistics  ************************
//================================================================================
  std::cout << std::endl << "*** TC Layer statistics ***" << std::endl;
  std::cout << "  Packets dropped by the TC layer R1 : " << q1->GetTotalDroppedPackets () << std::endl;
  std::cout << "  Packets dropped by the TC layer R2 : " << q2->GetTotalDroppedPackets () << std::endl;
//  std::cout << "  Bytes dropped by the TC layer: " << q1->GetTotalDroppedBytes () << std::endl;


  if (flow_monitor)
    {
      fmHelper.SerializeToXmlFile (prefix_file_name + ".flowmonitor", false,false);
    }
}
